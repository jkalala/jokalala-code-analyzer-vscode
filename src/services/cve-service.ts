/**
 * CVE Lookup Service
 *
 * Provides CVE information lookup and fix recommendations using the
 * Jokalala RAG-based CVE database API.
 */

import axios from 'axios'
import * as vscode from 'vscode'
import { ConfigurationService } from './configuration-service'
import { Logger } from './logger'

export interface CVEMatch {
  cveId: string
  title: string
  description: string
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW'
  owaspCategory: string
  confidence: number
  fix?: CVEFix
  references: string[]
}

export interface CVEFix {
  language: string
  description: string
  vulnerableCode: string
  secureCode: string
  explanation: string[]
  frameworks?: Record<string, string>
}

export interface CVELookupRequest {
  query?: string
  cweId?: string
  vulnerabilityType?: string
  language?: string
  code?: string
}

export interface CVELookupResponse {
  success: boolean
  data?: {
    matches: CVEMatch[]
    recommendations: string[]
  }
  error?: string
}

export class CVEService {
  private cache: Map<string, { data: CVELookupResponse; timestamp: number }> = new Map()
  private readonly CACHE_TTL = 5 * 60 * 1000 // 5 minutes

  constructor(
    private readonly configuration: ConfigurationService,
    private readonly logger: Logger
  ) {}

  /**
   * Look up CVE information based on search criteria
   */
  async lookupCVE(request: CVELookupRequest): Promise<CVELookupResponse> {
    const cacheKey = JSON.stringify(request)

    // Check cache first
    const cached = this.cache.get(cacheKey)
    if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
      this.logger.info('CVE lookup cache hit')
      return cached.data
    }

    const settings = this.configuration.getSettings()
    const apiEndpoint = settings.apiEndpoint?.replace(/\/$/, '')

    if (!apiEndpoint) {
      return {
        success: false,
        error: 'API endpoint not configured'
      }
    }

    const cveLookupUrl = `${apiEndpoint}/cve-lookup`

    try {
      this.logger.info(`CVE lookup request to: ${cveLookupUrl}`)

      const response = await axios.post<CVELookupResponse>(
        cveLookupUrl,
        request,
        {
          headers: {
            'Content-Type': 'application/json',
            ...(settings.apiKey && { Authorization: `Bearer ${settings.apiKey}` })
          },
          timeout: settings.requestTimeout || 30000
        }
      )

      if (response.data.success) {
        // Cache the result
        this.cache.set(cacheKey, {
          data: response.data,
          timestamp: Date.now()
        })
      }

      return response.data
    } catch (error: any) {
      this.logger.error('CVE lookup failed', error)

      if (error.response?.status === 404) {
        return {
          success: false,
          error: 'CVE lookup endpoint not available. Please update the Jokalala service.'
        }
      }

      return {
        success: false,
        error: error.message || 'CVE lookup failed'
      }
    }
  }

  /**
   * Look up CVE by CWE ID
   */
  async lookupByCWE(cweId: string, language?: string): Promise<CVELookupResponse> {
    const request: CVELookupRequest = { cweId }
    if (language) request.language = language
    return this.lookupCVE(request)
  }

  /**
   * Look up CVE by vulnerability type
   */
  async lookupByType(vulnerabilityType: string, language?: string): Promise<CVELookupResponse> {
    const request: CVELookupRequest = { vulnerabilityType }
    if (language) request.language = language
    return this.lookupCVE(request)
  }

  /**
   * Analyze code for potential CVE matches
   */
  async analyzeCodeForCVEs(code: string, language: string): Promise<CVELookupResponse> {
    return this.lookupCVE({ code, language })
  }

  /**
   * Search CVEs by query
   */
  async searchCVEs(query: string, language?: string): Promise<CVELookupResponse> {
    const request: CVELookupRequest = { query }
    if (language) request.language = language
    return this.lookupCVE(request)
  }

  /**
   * Get a specific fix for a vulnerability
   */
  async getFix(cweId: string, language: string): Promise<CVEFix | undefined> {
    const response = await this.lookupByCWE(cweId, language)

    if (response.success && response.data?.matches.length) {
      const match = response.data.matches[0]
      if (match) {
        return match.fix
      }
    }

    return undefined
  }

  /**
   * Apply a CVE fix to the document
   */
  async applyFix(
    document: vscode.TextDocument,
    range: vscode.Range,
    fix: CVEFix
  ): Promise<boolean> {
    try {
      const documentText = document.getText()
      const vulnerableCode = fix.vulnerableCode.trim()
      const secureCode = fix.secureCode.trim()

      // Try to find the vulnerable code pattern in the document
      const vulnerableIndex = documentText.indexOf(vulnerableCode)

      const edit = new vscode.WorkspaceEdit()

      if (vulnerableIndex !== -1) {
        // Found exact match - replace it
        const startPos = document.positionAt(vulnerableIndex)
        const endPos = document.positionAt(vulnerableIndex + vulnerableCode.length)
        const matchRange = new vscode.Range(startPos, endPos)
        edit.replace(document.uri, matchRange, secureCode)
      } else {
        // Use the provided range
        edit.replace(document.uri, range, secureCode)
      }

      const success = await vscode.workspace.applyEdit(edit)

      if (success) {
        vscode.window.showInformationMessage(
          `Applied security fix: ${fix.description}`
        )
      }

      return success
    } catch (error: any) {
      this.logger.error('Failed to apply CVE fix', error)
      vscode.window.showErrorMessage(`Failed to apply fix: ${error.message}`)
      return false
    }
  }

  /**
   * Show CVE details in a webview panel
   */
  showCVEDetails(match: CVEMatch): void {
    const panel = vscode.window.createWebviewPanel(
      'cveDetails',
      `CVE: ${match.title}`,
      vscode.ViewColumn.Beside,
      { enableScripts: true }
    )

    panel.webview.html = this.generateCVEDetailsHtml(match)
  }

  /**
   * Generate HTML for CVE details panel
   */
  private generateCVEDetailsHtml(match: CVEMatch): string {
    const confidence = Math.round(match.confidence * 100)
    const severityColor = {
      CRITICAL: '#dc2626',
      HIGH: '#f97316',
      MEDIUM: '#eab308',
      LOW: '#22c55e'
    }[match.severity] || '#6b7280'

    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: var(--vscode-font-family);
      padding: 20px;
      color: var(--vscode-editor-foreground);
      background: var(--vscode-editor-background);
    }
    h1 { margin-top: 0; font-size: 1.5em; }
    h2 { font-size: 1.2em; margin-top: 1.5em; }
    .severity {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 4px;
      font-weight: bold;
      color: white;
      background: ${severityColor};
    }
    .confidence {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 4px;
      background: #3b82f6;
      color: white;
      margin-left: 8px;
    }
    .owasp {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 4px;
      background: #8b5cf6;
      color: white;
      margin-left: 8px;
    }
    .section {
      margin: 20px 0;
      padding: 15px;
      background: var(--vscode-textBlockQuote-background);
      border-radius: 8px;
    }
    pre {
      background: var(--vscode-textCodeBlock-background);
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
      font-size: 13px;
    }
    .code-vulnerable {
      border-left: 4px solid #dc2626;
    }
    .code-secure {
      border-left: 4px solid #22c55e;
    }
    .explanation {
      list-style: none;
      padding: 0;
    }
    .explanation li {
      padding: 8px 0;
      border-bottom: 1px solid var(--vscode-widget-border);
    }
    .explanation li:last-child {
      border-bottom: none;
    }
    .explanation li::before {
      content: "‚úì ";
      color: #22c55e;
    }
    .framework {
      margin-top: 15px;
      padding: 10px;
      background: var(--vscode-editor-inactiveSelectionBackground);
      border-radius: 4px;
    }
    .framework h4 {
      margin: 0 0 10px 0;
      font-size: 0.9em;
      color: var(--vscode-descriptionForeground);
    }
    .references {
      margin-top: 20px;
    }
    .references a {
      color: var(--vscode-textLink-foreground);
      display: block;
      padding: 4px 0;
    }
    button {
      padding: 10px 20px;
      margin-right: 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    .btn-primary {
      background: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
    }
    .btn-secondary {
      background: var(--vscode-button-secondaryBackground);
      color: var(--vscode-button-secondaryForeground);
    }
  </style>
</head>
<body>
  <h1>${match.cveId}: ${match.title}</h1>

  <div style="margin: 15px 0;">
    <span class="severity">${match.severity}</span>
    <span class="confidence">${confidence}% Match</span>
    <span class="owasp">${match.owaspCategory}</span>
  </div>

  <div class="section">
    <p>${match.description}</p>
  </div>

  ${match.fix ? `
  <h2>üîß Recommended Fix (${match.fix.language})</h2>
  <p><strong>${match.fix.description}</strong></p>

  <h3>‚ùå Vulnerable Code</h3>
  <pre class="code-vulnerable"><code>${this.escapeHtml(match.fix.vulnerableCode)}</code></pre>

  <h3>‚úÖ Secure Code</h3>
  <pre class="code-secure"><code>${this.escapeHtml(match.fix.secureCode)}</code></pre>

  <h3>üìñ Explanation</h3>
  <ul class="explanation">
    ${match.fix.explanation.map(e => `<li>${this.escapeHtml(e)}</li>`).join('')}
  </ul>

  ${match.fix.frameworks ? `
  <h3>üõ†Ô∏è Framework-Specific Solutions</h3>
  ${Object.entries(match.fix.frameworks).map(([name, code]) => `
    <div class="framework">
      <h4>${name}</h4>
      <pre><code>${this.escapeHtml(code)}</code></pre>
    </div>
  `).join('')}
  ` : ''}
  ` : '<p>No specific fix available for this vulnerability.</p>'}

  <div class="references">
    <h3>üìö References</h3>
    ${match.references.map(ref => `<a href="${ref}" target="_blank">${ref}</a>`).join('')}
  </div>
</body>
</html>`
  }

  /**
   * Escape HTML for safe display
   */
  private escapeHtml(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;')
  }

  /**
   * Clear the CVE cache
   */
  clearCache(): void {
    this.cache.clear()
    this.logger.info('CVE cache cleared')
  }
}
