"use strict";
/**
 * CVE Tree Provider
 *
 * Displays CVE matches and recommendations in the VS Code sidebar.
 * Provides quick access to vulnerability information and one-click fixes.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.CVETreeProvider = void 0;
exports.registerCVETreeView = registerCVETreeView;
const vscode = __importStar(require("vscode"));
class CVETreeProvider {
    constructor() {
        Object.defineProperty(this, "_onDidChangeTreeData", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new vscode.EventEmitter()
        });
        Object.defineProperty(this, "onDidChangeTreeData", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: this._onDidChangeTreeData.event
        });
        Object.defineProperty(this, "matches", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "recommendations", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "isLoading", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "errorMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: null
        });
    }
    /**
     * Update the CVE matches to display
     */
    updateMatches(matches, recommendations) {
        this.matches = matches;
        this.recommendations = recommendations;
        this.errorMessage = null;
        this._onDidChangeTreeData.fire(undefined);
    }
    /**
     * Set loading state
     */
    setLoading(loading) {
        this.isLoading = loading;
        this._onDidChangeTreeData.fire(undefined);
    }
    /**
     * Set error message
     */
    setError(message) {
        this.errorMessage = message;
        this._onDidChangeTreeData.fire(undefined);
    }
    /**
     * Clear all data
     */
    clear() {
        this.matches = [];
        this.recommendations = [];
        this.errorMessage = null;
        this._onDidChangeTreeData.fire(undefined);
    }
    getTreeItem(element) {
        return element;
    }
    getChildren(element) {
        if (!element) {
            // Root level
            return this.getRootItems();
        }
        if (element instanceof CVEGroupItem) {
            return element.children;
        }
        if (element instanceof CVEMatchItem) {
            return this.getCVEMatchChildren(element.match);
        }
        return [];
    }
    getRootItems() {
        const items = [];
        // Loading state
        if (this.isLoading) {
            items.push(new CVEInfoItem('$(sync~spin) Searching for CVEs...', 'loading'));
            return items;
        }
        // Error state
        if (this.errorMessage) {
            items.push(new CVEInfoItem(`$(error) ${this.errorMessage}`, 'error'));
            return items;
        }
        // No matches
        if (this.matches.length === 0) {
            items.push(new CVEInfoItem('$(pass) No vulnerabilities detected', 'info'));
            items.push(new CVEInfoItem('Run analysis to detect CVEs', 'hint'));
            return items;
        }
        // Group by severity
        const critical = this.matches.filter(m => m.severity === 'CRITICAL');
        const high = this.matches.filter(m => m.severity === 'HIGH');
        const medium = this.matches.filter(m => m.severity === 'MEDIUM');
        const low = this.matches.filter(m => m.severity === 'LOW');
        if (critical.length > 0) {
            items.push(new CVEGroupItem(`Critical (${critical.length})`, critical.map(m => new CVEMatchItem(m)), 'critical'));
        }
        if (high.length > 0) {
            items.push(new CVEGroupItem(`High (${high.length})`, high.map(m => new CVEMatchItem(m)), 'high'));
        }
        if (medium.length > 0) {
            items.push(new CVEGroupItem(`Medium (${medium.length})`, medium.map(m => new CVEMatchItem(m)), 'medium'));
        }
        if (low.length > 0) {
            items.push(new CVEGroupItem(`Low (${low.length})`, low.map(m => new CVEMatchItem(m)), 'low'));
        }
        // Recommendations section
        if (this.recommendations.length > 0) {
            items.push(new CVEGroupItem('Recommendations', this.recommendations.map(r => new CVEInfoItem(r, 'recommendation')), 'recommendations'));
        }
        return items;
    }
    getCVEMatchChildren(match) {
        const items = [];
        // Confidence
        const confidence = Math.round(match.confidence * 100);
        items.push(new CVEInfoItem(`$(dashboard) ${confidence}% confidence`, 'confidence'));
        // OWASP Category
        items.push(new CVEInfoItem(`$(shield) ${match.owaspCategory}`, 'owasp'));
        // Fix available
        if (match.fix) {
            items.push(new CVEFixItem(match.fix, match));
        }
        // References
        if (match.references.length > 0) {
            items.push(new CVEInfoItem(`$(book) ${match.references.length} references`, 'references'));
        }
        return items;
    }
}
exports.CVETreeProvider = CVETreeProvider;
/**
 * Group item for categorizing CVEs by severity
 */
class CVEGroupItem extends vscode.TreeItem {
    constructor(label, children, groupType) {
        super(label, vscode.TreeItemCollapsibleState.Expanded);
        Object.defineProperty(this, "children", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: children
        });
        Object.defineProperty(this, "groupType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: groupType
        });
        const iconMap = {
            critical: new vscode.ThemeIcon('error', new vscode.ThemeColor('errorForeground')),
            high: new vscode.ThemeIcon('warning', new vscode.ThemeColor('editorWarning.foreground')),
            medium: new vscode.ThemeIcon('info', new vscode.ThemeColor('editorInfo.foreground')),
            low: new vscode.ThemeIcon('circle-outline'),
            recommendations: new vscode.ThemeIcon('lightbulb')
        };
        this.iconPath = iconMap[groupType];
        this.contextValue = `cveGroup-${groupType}`;
    }
}
/**
 * Tree item representing a CVE match
 */
class CVEMatchItem extends vscode.TreeItem {
    constructor(match) {
        super(match.title, vscode.TreeItemCollapsibleState.Collapsed);
        Object.defineProperty(this, "match", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: match
        });
        this.description = match.cveId;
        this.tooltip = new vscode.MarkdownString(`**${match.title}**\n\n` +
            `${match.description}\n\n` +
            `- Severity: ${match.severity}\n` +
            `- OWASP: ${match.owaspCategory}\n` +
            `- Confidence: ${Math.round(match.confidence * 100)}%`);
        const severityIcon = {
            CRITICAL: new vscode.ThemeIcon('flame', new vscode.ThemeColor('errorForeground')),
            HIGH: new vscode.ThemeIcon('alert', new vscode.ThemeColor('editorWarning.foreground')),
            MEDIUM: new vscode.ThemeIcon('warning', new vscode.ThemeColor('editorInfo.foreground')),
            LOW: new vscode.ThemeIcon('info')
        };
        this.iconPath = severityIcon[match.severity];
        this.contextValue = 'cveMatch';
        // Command to show details
        this.command = {
            command: 'jokalala.showCVEDetails',
            title: 'Show CVE Details',
            arguments: [match]
        };
    }
}
/**
 * Tree item representing an available fix
 */
class CVEFixItem extends vscode.TreeItem {
    constructor(fix, match) {
        super(`Fix: ${fix.description}`, vscode.TreeItemCollapsibleState.None);
        Object.defineProperty(this, "fix", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: fix
        });
        Object.defineProperty(this, "match", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: match
        });
        this.description = fix.language;
        this.tooltip = new vscode.MarkdownString(`**Apply Fix**\n\n` +
            `${fix.description}\n\n` +
            `Language: ${fix.language}\n\n` +
            `Click to apply this fix automatically.`);
        this.iconPath = new vscode.ThemeIcon('wrench', new vscode.ThemeColor('terminal.ansiGreen'));
        this.contextValue = 'cveFix';
        // Command to apply fix
        this.command = {
            command: 'jokalala.applyCVEFix',
            title: 'Apply CVE Fix',
            arguments: [fix, match]
        };
    }
}
/**
 * Generic info item for displaying various information
 */
class CVEInfoItem extends vscode.TreeItem {
    constructor(label, infoType) {
        super(label, vscode.TreeItemCollapsibleState.None);
        Object.defineProperty(this, "infoType", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: infoType
        });
        const iconMap = {
            loading: new vscode.ThemeIcon('sync~spin'),
            error: new vscode.ThemeIcon('error', new vscode.ThemeColor('errorForeground')),
            info: new vscode.ThemeIcon('check', new vscode.ThemeColor('terminal.ansiGreen')),
            hint: new vscode.ThemeIcon('lightbulb'),
            confidence: new vscode.ThemeIcon('dashboard'),
            owasp: new vscode.ThemeIcon('shield'),
            references: new vscode.ThemeIcon('book'),
            recommendation: new vscode.ThemeIcon('lightbulb-autofix')
        };
        const icon = iconMap[infoType];
        if (icon) {
            this.iconPath = icon;
        }
        this.contextValue = `cveInfo-${infoType}`;
    }
}
/**
 * Register CVE tree view and related commands
 */
function registerCVETreeView(context, provider) {
    const treeView = vscode.window.createTreeView('jokalala-cve', {
        treeDataProvider: provider,
        showCollapseAll: true
    });
    context.subscriptions.push(treeView);
    return treeView;
}
//# sourceMappingURL=cve-tree-provider.js.map