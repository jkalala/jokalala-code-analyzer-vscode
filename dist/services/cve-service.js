"use strict";
/**
 * CVE Lookup Service
 *
 * Provides CVE information lookup and fix recommendations using the
 * Jokalala RAG-based CVE database API.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CVEService = void 0;
const axios_1 = __importDefault(require("axios"));
const vscode = __importStar(require("vscode"));
class CVEService {
    constructor(configuration, logger) {
        Object.defineProperty(this, "configuration", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: configuration
        });
        Object.defineProperty(this, "logger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: logger
        });
        Object.defineProperty(this, "cache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
        Object.defineProperty(this, "CACHE_TTL", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 5 * 60 * 1000
        }); // 5 minutes
    }
    /**
     * Look up CVE information based on search criteria
     */
    async lookupCVE(request) {
        const cacheKey = JSON.stringify(request);
        // Check cache first
        const cached = this.cache.get(cacheKey);
        if (cached && Date.now() - cached.timestamp < this.CACHE_TTL) {
            this.logger.info('CVE lookup cache hit');
            return cached.data;
        }
        const settings = this.configuration.getSettings();
        const apiEndpoint = settings.apiEndpoint?.replace(/\/$/, '');
        if (!apiEndpoint) {
            return {
                success: false,
                error: 'API endpoint not configured'
            };
        }
        const cveLookupUrl = `${apiEndpoint}/cve-lookup`;
        try {
            this.logger.info(`CVE lookup request to: ${cveLookupUrl}`);
            const response = await axios_1.default.post(cveLookupUrl, request, {
                headers: {
                    'Content-Type': 'application/json',
                    ...(settings.apiKey && { Authorization: `Bearer ${settings.apiKey}` })
                },
                timeout: settings.requestTimeout || 30000
            });
            if (response.data.success) {
                // Cache the result
                this.cache.set(cacheKey, {
                    data: response.data,
                    timestamp: Date.now()
                });
            }
            return response.data;
        }
        catch (error) {
            this.logger.error('CVE lookup failed', error);
            if (error.response?.status === 404) {
                return {
                    success: false,
                    error: 'CVE lookup endpoint not available. Please update the Jokalala service.'
                };
            }
            return {
                success: false,
                error: error.message || 'CVE lookup failed'
            };
        }
    }
    /**
     * Look up CVE by CWE ID
     */
    async lookupByCWE(cweId, language) {
        const request = { cweId };
        if (language)
            request.language = language;
        return this.lookupCVE(request);
    }
    /**
     * Look up CVE by vulnerability type
     */
    async lookupByType(vulnerabilityType, language) {
        const request = { vulnerabilityType };
        if (language)
            request.language = language;
        return this.lookupCVE(request);
    }
    /**
     * Analyze code for potential CVE matches
     */
    async analyzeCodeForCVEs(code, language) {
        return this.lookupCVE({ code, language });
    }
    /**
     * Search CVEs by query
     */
    async searchCVEs(query, language) {
        const request = { query };
        if (language)
            request.language = language;
        return this.lookupCVE(request);
    }
    /**
     * Get a specific fix for a vulnerability
     */
    async getFix(cweId, language) {
        const response = await this.lookupByCWE(cweId, language);
        if (response.success && response.data?.matches.length) {
            const match = response.data.matches[0];
            if (match) {
                return match.fix;
            }
        }
        return undefined;
    }
    /**
     * Apply a CVE fix to the document
     */
    async applyFix(document, range, fix) {
        try {
            const documentText = document.getText();
            const vulnerableCode = fix.vulnerableCode.trim();
            const secureCode = fix.secureCode.trim();
            // Try to find the vulnerable code pattern in the document
            const vulnerableIndex = documentText.indexOf(vulnerableCode);
            const edit = new vscode.WorkspaceEdit();
            if (vulnerableIndex !== -1) {
                // Found exact match - replace it
                const startPos = document.positionAt(vulnerableIndex);
                const endPos = document.positionAt(vulnerableIndex + vulnerableCode.length);
                const matchRange = new vscode.Range(startPos, endPos);
                edit.replace(document.uri, matchRange, secureCode);
            }
            else {
                // Use the provided range
                edit.replace(document.uri, range, secureCode);
            }
            const success = await vscode.workspace.applyEdit(edit);
            if (success) {
                vscode.window.showInformationMessage(`Applied security fix: ${fix.description}`);
            }
            return success;
        }
        catch (error) {
            this.logger.error('Failed to apply CVE fix', error);
            vscode.window.showErrorMessage(`Failed to apply fix: ${error.message}`);
            return false;
        }
    }
    /**
     * Show CVE details in a webview panel
     */
    showCVEDetails(match) {
        const panel = vscode.window.createWebviewPanel('cveDetails', `CVE: ${match.title}`, vscode.ViewColumn.Beside, { enableScripts: true });
        panel.webview.html = this.generateCVEDetailsHtml(match);
    }
    /**
     * Generate HTML for CVE details panel
     */
    generateCVEDetailsHtml(match) {
        const confidence = Math.round(match.confidence * 100);
        const severityColor = {
            CRITICAL: '#dc2626',
            HIGH: '#f97316',
            MEDIUM: '#eab308',
            LOW: '#22c55e'
        }[match.severity] || '#6b7280';
        return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: var(--vscode-font-family);
      padding: 20px;
      color: var(--vscode-editor-foreground);
      background: var(--vscode-editor-background);
    }
    h1 { margin-top: 0; font-size: 1.5em; }
    h2 { font-size: 1.2em; margin-top: 1.5em; }
    .severity {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 4px;
      font-weight: bold;
      color: white;
      background: ${severityColor};
    }
    .confidence {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 4px;
      background: #3b82f6;
      color: white;
      margin-left: 8px;
    }
    .owasp {
      display: inline-block;
      padding: 4px 12px;
      border-radius: 4px;
      background: #8b5cf6;
      color: white;
      margin-left: 8px;
    }
    .section {
      margin: 20px 0;
      padding: 15px;
      background: var(--vscode-textBlockQuote-background);
      border-radius: 8px;
    }
    pre {
      background: var(--vscode-textCodeBlock-background);
      padding: 15px;
      border-radius: 4px;
      overflow-x: auto;
      font-size: 13px;
    }
    .code-vulnerable {
      border-left: 4px solid #dc2626;
    }
    .code-secure {
      border-left: 4px solid #22c55e;
    }
    .explanation {
      list-style: none;
      padding: 0;
    }
    .explanation li {
      padding: 8px 0;
      border-bottom: 1px solid var(--vscode-widget-border);
    }
    .explanation li:last-child {
      border-bottom: none;
    }
    .explanation li::before {
      content: "‚úì ";
      color: #22c55e;
    }
    .framework {
      margin-top: 15px;
      padding: 10px;
      background: var(--vscode-editor-inactiveSelectionBackground);
      border-radius: 4px;
    }
    .framework h4 {
      margin: 0 0 10px 0;
      font-size: 0.9em;
      color: var(--vscode-descriptionForeground);
    }
    .references {
      margin-top: 20px;
    }
    .references a {
      color: var(--vscode-textLink-foreground);
      display: block;
      padding: 4px 0;
    }
    button {
      padding: 10px 20px;
      margin-right: 10px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    .btn-primary {
      background: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
    }
    .btn-secondary {
      background: var(--vscode-button-secondaryBackground);
      color: var(--vscode-button-secondaryForeground);
    }
  </style>
</head>
<body>
  <h1>${match.cveId}: ${match.title}</h1>

  <div style="margin: 15px 0;">
    <span class="severity">${match.severity}</span>
    <span class="confidence">${confidence}% Match</span>
    <span class="owasp">${match.owaspCategory}</span>
  </div>

  <div class="section">
    <p>${match.description}</p>
  </div>

  ${match.fix ? `
  <h2>üîß Recommended Fix (${match.fix.language})</h2>
  <p><strong>${match.fix.description}</strong></p>

  <h3>‚ùå Vulnerable Code</h3>
  <pre class="code-vulnerable"><code>${this.escapeHtml(match.fix.vulnerableCode)}</code></pre>

  <h3>‚úÖ Secure Code</h3>
  <pre class="code-secure"><code>${this.escapeHtml(match.fix.secureCode)}</code></pre>

  <h3>üìñ Explanation</h3>
  <ul class="explanation">
    ${match.fix.explanation.map(e => `<li>${this.escapeHtml(e)}</li>`).join('')}
  </ul>

  ${match.fix.frameworks ? `
  <h3>üõ†Ô∏è Framework-Specific Solutions</h3>
  ${Object.entries(match.fix.frameworks).map(([name, code]) => `
    <div class="framework">
      <h4>${name}</h4>
      <pre><code>${this.escapeHtml(code)}</code></pre>
    </div>
  `).join('')}
  ` : ''}
  ` : '<p>No specific fix available for this vulnerability.</p>'}

  <div class="references">
    <h3>üìö References</h3>
    ${match.references.map(ref => `<a href="${ref}" target="_blank">${ref}</a>`).join('')}
  </div>
</body>
</html>`;
    }
    /**
     * Escape HTML for safe display
     */
    escapeHtml(text) {
        return text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    }
    /**
     * Clear the CVE cache
     */
    clearCache() {
        this.cache.clear();
        this.logger.info('CVE cache cleared');
    }
}
exports.CVEService = CVEService;
//# sourceMappingURL=cve-service.js.map